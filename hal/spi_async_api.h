/** \ingroup hal_spi */
/** @{*/
/* mbed Microcontroller Library
 * Copyright (c) 2006-2018 ARM Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MBED_SPI_API_ASYNC_H
#define MBED_SPI_API_ASYNC_H

#include "hal/spi_api.h"

#if DEVICE_SPI
#if DEVICE_SPI_ASYNCH

/** \defgroup hal_spi_async SPI: Asynchronous API.
 *
 * This sub API complete the set of functions provided by the SPI API to enable asynchronous access
 * to the peripheral.
 *
 * - Schedule/enqueue a transaction.
 * - eventually cancel/abort the transaction.
 * - release the transaction (before or after its completion).
 *
 * # Defined behaviour
 * - `spi_async_transfer_new()` returns NULL if any of `spi_t *obj` or `spi_transfer_args_t *args` is NULL.
 * - `spi_async_transfer_new()` schedules a transfer using the given parameters.
 *   All parameters and the embedded references must stay "alive" until completion of the operation.
 * - `spi_async_transfer_new()` returns a reference counted handle on the scheduled operation.
 * - `spi_async_transfer_free()` does nothing if passed a NULL pointer.
 * - `spi_async_transfer_free()` notifies the lowlevel implementation that this reference is no longer
 *   owned used in the client application (upper/layer code).
 * - `spi_async_transfer_free()` does **NOT** cancel nor abort a transaction if called before completion.
 * - `spi_async_transfer_abort()` notifies the lowlevel implementation that the given transaction must be
 *   cancelled (if not already started) or aborted (if currently running).
 * - When the operation completes (normally or because of abortion or error) the callback is invoked
 *   with the provided context and a "reason" describing what triggered the completion.
 *   This call might be running in an interrupt context and thus all contrainsts applying to ISR
 *   handler applies to this callback.
 * - `spi_async_transfer_abort()` does nothing if called on an already completed transaction.
 * - `spi_async_transfer_abort()` may not wait for the transaction to be cancelled/aborted and returns
 *   immediatly.
 * - `spi_free()` cancels and aborts all transactions enqueued for this spi_t.
 * - the callback passed in spi_async_transfer_new is called only once.
 *
 * # Undefined behaviour
 * - Calling `spi_async_free_handle()` more than one time on a `spi_async_tranfer_t`.
 * - Calling `spi_async_abort()` after calling `spi_async_free_handle()`.
 *
 * # What this API does not cover
 * The following elements are not covered by this API and are considered implementation details :
 * - The use of Interrupts and/or DMA for async operations.
 * - The way `spi_transfer()` is implemented : using specific to this function or using
 *   `spi_async_transfer()`.
 * - Wether the SS pin is controlled by hardware or software.
 * - The way `spi_async_abort()` is implemented : abortion callback invoked in the same thread before
 *   returning, in an interrupt or in another thread.
 *
 * @{
 *
 * \struct spi_async_tranfer_t
 * This needs to be declared and defined by the low level device driver.
 * It is used to eventually abort an async request before its completion. see spi_async_abort.
 */

/**
 * This enumerates the possible event types generated by the SPI ASYNC api.
 */
typedef enum spi_event_type_t {
    SPI_EVENT_TYPE_ON_DONE, /**< The operation has completed successfully. */
    SPI_EVENT_TYPE_ON_ABORT, /**< The operation has been aborted. */
    SPI_EVENT_TYPE_ON_ERROR /**< An error occured. */
} spi_event_type_t;

/**
 * Signature for a SPI async completion event.
 *
 * As this may be executed from an interrupt context it is highly adviced to restrict this callback
 * to signaling completion to a thread.
 */
typedef void (*spi_event_f)(void *context, spi_event_type_t evtype);

#ifdef __cplusplus
extern "C" {
#endif
/**
 * SPI asynchronous transfer type.
 * This has to be defined by the low-level implementation.
 * This is only manipulated by pointer and thus can be an opaque type.
 */
typedef struct spi_async_transfer_s spi_async_transfer_t;

/**
 * Schedules a transfer using the given parameters.
 * @warning All parameters and the embedded references must stay "alive" until completion of the operation.
 *
 * @param[in,out] obj       A pointer to a spi_t object.
 * @param[in,out] args      A pointer to a spi_transfer_args_t object.
 * @param[in]     context   A context to be used by the callback.
 * @param[in]     cb        A callback invoked upon completion of this transaction.
 *
 * @return A reference counted handle to the transaction.
 */
spi_async_transfer_t* spi_async_transfer_new(
    spi_t *obj,
    spi_transfer_args_t *args,
    void *context,
    spi_event_f cb);

/**
 * Aborts the transaction referenced by the spi_async_tranfer_t.
 *
 * This function notifies the lowlevel implementation that the given transaction must be cancelled
 * (if not already started) or aborted (if currently running) and returns.
 *
 * The callback associated with this spi_async_tranfer_t will be invoked with SPI_EVENT_TYPE_ON_ABORT
 * as its evtype argument.
 *
 * This does nothing when used on an already cancelled/aborted transaction.
 *
 * @param[in] transfer A spi_async_tranfer_t object.
 *
 * The handle is consumed in this operation and should no longer be used.
 */
void spi_async_transfer_abort(spi_async_transfer_t* transfer);

/**
 * Tells the low-level driver that the upper layer is no longer keeping this handle.
 *
 * This does nothing if passed a NULL pointer.
 *
 * @param[in] transfer A spi_async_tranfer_t object.
 */
void spi_async_transfer_free(spi_async_tranfer_t* transfer);

/**
 * \func spi_free
 *
 * A SPI instance cannot be released if any reference to an asynchronous transaction is still alive.
 *
 * @warning An asynchronous transaction might be completed/errored/aborted and still alive if
 * `spi_async_free_handle()` has not beed called yet on it.
 *
 */
#ifdef __cplusplus
}
#endif

/**
 * @}
 */

#endif /* DEVICE_SPI_ASYNCH */
#endif /* DEVICE_SPI */

#endif /* MBED_SPI_API_ASYNC_H */
/**
 * @}
 */

